{"name":"The ONE","tagline":"The Opportunistic Network Environment simulator.","body":"ONE\r\n===\r\n\r\nThe Opportunistic Network Environment simulator.\r\n\r\n\r\nThe ONE v1.5.0 - Readme\r\n=======================\r\n\r\nThe ONE is a Opportunistic Network Environment simulator which provides a\r\npowerful tool for generating mobility traces, running DTN messaging\r\nsimulations with different routing protocols, and visualizing both\r\nsimulations interactively in real-time and results after their completion.\r\n\r\n\r\nQuick start\r\n===========\r\n\r\nCompiling\r\n---------\r\n\r\nYou can compile ONE from the source code using the included compile.bat\r\nscript. That should work both in Windows and Unix/Linux environment with\r\nJava 6 JDK or later.\r\n\r\nIf you want to use Eclipse for compiling the ONE, since version 1.1.0 you need\r\nto include some jar libraries in the project's build path. The libraries are \r\nlocated in the lib folder. To include them in Eclipse, assuming that you have \r\nan Eclipse Java project whose root folder is the folder where you extracted \r\nthe ONE, do the following:\r\n \r\nselect from menus: Project -> Properties -> Java Build Path\r\nGo to \"Libraries\" tab\r\nClick \"Add JARs...\"\r\nSelect \"DTNConsoleConnection.jar\" under the \"lib\" folder\r\nAdd the \"ECLA.jar\" the same way\r\nPress \"OK\".\r\n\r\nNow Eclipse should be able to compile the ONE without warnings.\r\n\r\n\r\nRunning\r\n-------\r\n\r\nONE can be started using the included one.bat (for Windows) or one.sh (for\r\nLinux/Unix) script. Following examples assume you're using the Linux/Unix\r\nscript (just replace \"./one.sh\" with \"one.bat\" for Windows).\r\n\r\nSynopsis:\r\n./one.sh [-b runcount] [conf-files]\r\n\r\nOptions:\r\n  -b Run simulation in batch mode. Doesn't start GUI but prints\r\ninformation about the progress to terminal. The option must be followed \r\nby the number of runs to perform in the batch mode or by a range of runs \r\nto perform, delimited with a colon (e.g, value 2:4 would perform runs 2, \r\n3 and 4). See section \"Run indexing\" for more information.\r\n  \r\nParameters:  \r\n  conf-files: The configuration file names where simulation parameters\r\nare read from. Any number of configuration files can be defined and they are\r\nread in the order given in the command line. Values in the later config files \r\noverride values in earlier config files.\r\n\r\n\r\nConfiguring\r\n===========\r\n\r\nAll simulation parameters are given using configuration files. These files\r\nare normal text files that contain key-value pairs. Syntax for most of the\r\nvariables is:\r\nNamespace.key = value\r\n\r\nI.e., the key is (usually) prefixed by a namespace, followed by a dot, and\r\nthen key name. Key and value are separated by equals-sign. Namespaces\r\nstart with capital letter and both namespace and keys are written in\r\nCamelCase (and are case sensitive). Namespace defines (loosely) the part\r\nof the simulation environment where the setting has effect on. Many, but\r\nnot all, namespaces are equal to the class name where they are read.\r\nEspecially movement models, report modules and routing modules follow this\r\nconvention. In some cases the namespace is defined by the user: e.g., with \r\nnetwork interfaces user can pick up any idenfitier, define interface specific \r\nsettings in that namespace, and give the name of the namespace when \r\nconfiguring which interface each group should use.\r\n\r\nNumeric values use '.' as the decimal separator and can be suffixed with\r\nkilo (k) mega (M) or giga (G) suffix. Boolean settings accept \"true\",\r\n\"false\", \"0\", and \"1\" as values.\r\n\r\nMany settings define paths to external data files. The paths can be relative \r\nor absolute but the directory separator must be '/' in both Unix and Windows \r\nenvironment.\r\n\r\nSome variables contain comma-separated values, and for them the syntax is:\r\nNamespace.key = value1, value2, value3, etc.\r\n\r\nFor run-indexed values the syntax is:\r\nNamespace.key = [run1value; run2value; run3value; etc]\r\nI.e., all values are given in brackets and values for different run are\r\nseparated by semicolon. Each value can also be a comma-separated value.\r\nFor more information about run indexing, go to section \"Run indexing\".\r\n\r\nSetting files can contain comments too. A comment line must start with \"#\" \r\ncharacter. Rest of the line is skipped when the settings are read. This can \r\nbe also useful for disabling settings easily.\r\n\r\nSome values (scenario and report names at the moment) support \"value\r\nfilling\". With this feature, you can construct e.g., scenario name\r\ndynamically from the setting values. This is especially useful when using\r\nrun indexing. Just put setting key names in the value part prefixed and\r\nsuffixed by two percent (%) signs. These placeholders are replaces by the\r\ncurrent setting value from the configuration file. See the included\r\nsnw_comparison_settings.txt for an example.\r\n\r\nFile \"default_settings.txt\", if exists, is always read and the other\r\nconfiguration files given as parameter can define more settings or override\r\nsome (or even all) settings in the previous files. The idea is that\r\nyou can define in the earlier files all the settings that are common for\r\nall the simulations and run different, specific, simulations using\r\ndifferent configuration files.\r\n\r\n\r\nRun indexing \r\n------------ \r\n\r\nRun indexing is a feature that allows you to run large amounts of\r\ndifferent configurations using only single configuration file. The idea is\r\nthat you provide an array of settings (using the syntax described above)\r\nfor the variables that should be changed between runs. For example, if you\r\nwant to run the simulation using five different random number generator\r\nseeds for movement models, you can define in the settings file the\r\nfollowing:\r\n\r\nMovementModel.rngSeed = [1; 2; 3; 4; 5]\r\n\r\nNow, if you run the simulation using command:\r\n\r\n./one.sh -b 5 my_config.txt\r\n\r\nyou would run first using seed 1 (run index 0), then another run using\r\nseed 2, etc. Note that you have to run it using batch mode (-b option) if\r\nyou want to use different values. Without the batch mode flag the first\r\nparameter (if numeric) is the run index to use when running in GUI mode.\r\n\r\nRun indexes wrap around: used value is the value at index (runIndex %\r\narrayLength). Because of wrapping, you can easily run large amount of\r\npermutations easily. For example, if you define two key-value pairs:\r\n\r\nkey1 = [1; 2] \r\nkey2 = [a; b; c]\r\n\r\nand run simulation using run-index count 6, you would get all permutations\r\nof the two values (1,a; 2,b; 1,c; 2,a; 1,b; 2,c). This naturally works\r\nwith any amount of arrays. Just make sure that the smallest common\r\nnominator of all array sizes is 1 (e.g., use arrays whose sizes are primes)\r\n-- unless you don't want all permutations but some values should be\r\npaired.\r\n\r\n\r\nMovement models\r\n---------------\r\n\r\nMovement models govern the way nodes move in the simulation. They provide \r\ncoordinates, speeds and pause times for the nodes. The basic installation \r\ncontains, e.g., random waypoint, map based movement, shortest path map based \r\nmovement, map route movement and external movement. All these models, except \r\nexternal movement, have configurable speed and pause time distributions. A \r\nminimum and maximum values can be given and the movement model draws \r\nuniformly distributed random values that are within the given range. Same \r\napplies for pause times. In external movement model the speeds and pause \r\ntimes are interpreted from the given data.\r\n\r\nWhen a node uses the random waypoint movement model (RandomWaypoint), it is \r\ngiven a random coordinate in the simulation area. Node moves directly to the \r\ngiven destination at constant speed, pauses for a while, and then gets a new \r\ndestination. This continues throughout the simulations and nodes move along \r\nthese zig-zag paths.\r\n\r\nMap-based movement models constrain the node movement to predefined paths.  \r\nDifferent types of paths can be defined and one can define valid paths for \r\nall node groups. This way e.g., cars can be prevented from driving indoors or \r\non pedestrian paths.\r\n\r\nThe basic map-based movement model (MapBasedMovement) initially distributes \r\nthe nodes between any two adjacent (i.e., connected by a path) map nodes and \r\nthen nodes start moving from adjacent map node to another. When node reaches \r\nthe next map node, it randomly selects the next adjacent map node but chooses \r\nthe map node where it came from only if that is the only option (i.e., avoids \r\ngoing back to where it came from). Once node has moved trough 10-100 map \r\nnodes, it pauses for a while and then starts moving again.\r\n\r\nThe more sophisticated version of the map-based movement model \r\n(ShortestPathMapBasedMovement) uses Dijkstra's shortest path algorithm to \r\nfind its way trough the map area. Once a node reaches its destination, and \r\nhas waited for the pause time, a new random map node is chosen and node moves \r\nthere using the shortest path that can be taken using only valid map nodes. \r\n\r\nFor the shortest path based movement models, map data can also contain Points \r\nOf Interest (POIs). Instead of selecting any random map node for the next \r\ndestination, the movement model can be configured to give a POI belonging to \r\na certain POI group with a configurable probability. There can be unlimited \r\namount of POI groups and all groups can contain any amount of POIs. All node \r\ngroups can have different probabilities for all POI groups. POIs can be used \r\nto model e.g., shops, restaurants and tourist attractions. \r\n\r\nRoute based movement model (MapRouteMovement) can be used to model nodes that \r\nfollow certain routes, e.g. bus or tram lines. Only the stops on the route \r\nhave to be defined and then the nodes using that route move from stop to stop \r\nusing shortest paths and stop on the stops for the configured time.\r\n\r\nAll movement models can also decide when the node is active (moves and can be \r\nconnected to) and when not. For all models, except for the external movement, \r\nmultiple simulation time intervals can be given and the nodes in that group \r\nwill be active only during those times. \r\n\r\nAll map-based models get their input data using files formatted with a subset \r\nof the Well Known Text (WKT) format. LINESTRING and MULTILINESTRING \r\ndirectives of WKT files are supported by the parser for map path data. For \r\npoint data (e.g. for POIs), also the POINT directive is supported. Adjacent \r\nnodes in a (MULTI)LINESTRING are considered to form a path and if some lines \r\ncontain some vertex(es) with exactly the same coordinates, the paths are \r\njoined from those places (this is how you create intersections). WKT files \r\ncan be edited and generated from real world map data using any suitable \r\nGeographic Information System (GIS) program. The map data included in the \r\nsimulator distribution was converted and edited using the free, Java based \r\nOpenJUMP GIS program.\r\n\r\nDifferent map types are defined by storing the paths belonging to different \r\ntypes to different files. Points Of Interest are simply defined with WKT \r\nPOINT directive and POI groups are defined by storing all POIs belonging to a \r\ncertain group in the same file. All POIs must also be part of the map data so \r\nthey are accessible using the paths. Stops for the routes are defined with \r\nLINESTRING and the stops are traversed in the same order they appear in the \r\nLINESTRING. One WKT file can contain multiple routes and they are given to \r\nnodes in the same order as they appear in the file.\r\n\r\nThe experimental movement model that uses external movement data \r\n(ExternalMovement) reads timestamped node locations from a file and moves the \r\nnodes in the simulation accordingly. See javadocs of ExternalMovementReader \r\nclass from input package for details of the format. A suitable, experimental \r\nconverter script (transimsParser.pl) for TRANSIMS data is included in the \r\ntoolkit folder.\r\n\r\nThe movement model to use is defined per node group with the \"movementModel\" \r\nsetting. Value of the setting must be a valid movement model class name from \r\nthe movement package. Settings that are common for all movement models are \r\nread in the MovementModel class and movement model specific settings are read \r\nin the respective classes. See the javadoc documentation and example \r\nconfiguration files for details. \r\n\r\nRouting modules and message creation\r\n------------------------------------\r\n\r\nRouting modules define how the messages are handled in the simulation. Six \r\nbasic active routing modules (First Contact, Epidemic, Spray and Wait, Direct \r\ndelivery, PRoPHET and MaxProp) and also a passive router for external routing \r\nsimulation are included in the package. The active routing modules are \r\nimplementations of the well known routing algorithms for DTN routing. There \r\nare also variants of these models and couple of different models included in \r\nthe latest versions. See the classes in the routing package for details.\r\n\r\nPassive router is made especially for interacting with other (DTN) routing \r\nsimulators or running simulations that don't need any routing functionality. \r\nThe router doesn't do anything unless commanded by external events. These \r\nexternal events are provided to the simulator by a class that implements the \r\nEventQueue interface.  \r\n\r\nThere are two basic classes that can be used as a source of message events: \r\nExternalEventsQueue and MessageEventGenerator. The former can read events \r\nfrom a file that can be created by hand, with a suitable script (e.g., \r\ncreateCreates.pl script in the toolkit folder), or by converting e.g., \r\ndtnsim2's output to suitable form. See StandardEventsReader class from input \r\npackage for details of the format. MessageEventGenerator is a simple message \r\ngenerator class that creates uniformly distributed message creation patterns \r\nwith configurable message creation interval, message size and \r\nsource/destination host ranges. More specific messaging scenarios can be \r\ncreated with MessageBurstGenerator, and One{From,To}EachMessageGenerator \r\nclasses. See javadocs for details.\r\n\r\nThe toolkit folder contains an experimental parser script (dtnsim2parser.pl) \r\nfor dtnsim2's output (there used to be a more capable Java-based parser but \r\nit was discarded in favor of this more easily extendable script). The script \r\nrequires a few patches to dtnsim2's code and those can be found from the \r\ntoolkit/dtnsim2patches folder.\r\n\r\nThe routing module to use is defined per node group with the setting \r\n\"router\". All routers can't interact properly (e.g., PRoPHET router can only \r\nwork with other PRoPHET routers) so usually it makes sense to use the same \r\n(or compatible) router for all groups.\r\n\r\nReports\r\n-------\r\n\r\nReports can be used to create summary data of simulation runs, detailed data \r\nof connections and messages, files suitable for post-processing using e.g., \r\nGraphviz (to create graphs) and also to interface with other programs. See \r\njavadocs of report-package classes for details.\r\n\r\nThere can be any number of reports for any simulation run and the number of \r\nreports to load is defined with \"Report.nrofReports\" setting. Report class \r\nnames are defined with \"Report.reportN\" setting, where N is an integer value \r\nstarting from 1. The values of the settings must be valid report class names \r\nfrom the report package. The output directory of all reports (which can be \r\noverridden per report class with the \"output\" setting) must be defined with \r\nReport.reportDir -setting. If no \"output\" setting is given for a report \r\nclass, the resulting report file name is \"ReportClassName_ScenarioName.txt\".\r\n\r\nAll reports have many configurable settings which can be defined using \r\nReportClassName.settingKey -syntax. See javadocs of Report class and specific \r\nreport classes for details (look for \"setting id\" definitions).\r\n\r\nHost groups\r\n-----------\r\n\r\nA host group is group of hosts (nodes) that shares movement and routing \r\nmodule settings. Different groups can have different values for the settings \r\nand this way they can represent different types of nodes. Base settings can \r\nbe defined in the \"Group\" namespace and different node groups can override \r\nthese settings or define new settings in their specific namespaces (Group1, \r\nGroup2, etc.). \r\n\r\nThe settings\r\n------------\r\n\r\nThere are plenty of settings to configure; more than is meaningful to\r\npresent here. See javadocs of especially report, routing and movement\r\nmodel classes for details. See also included settings files for examples.\r\nPerhaps the most important settings are the following.\r\n\r\n\r\nScenario settings:\r\n---\r\n\r\nScenario.name\r\nName of the scenario. All report files are by default prefixed with this.\r\n\r\nScenario.simulateConnections \r\nShould connections be simulated. If you're only interested in movement\r\nmodeling, you can disable this to get faster simulation. Usually you want\r\nthis to be on.\r\n\r\nScenario.updateInterval\r\nHow many seconds are stepped on every update. Increase this to get faster\r\nsimulation, but then you'll lose some precision. Values from 0.1 to 2 are good \r\nfor simulations.\r\n\r\nScenario.endTime\r\nHow many simulated seconds to simulate.\r\n\r\nScenario.nrofHostGroups\r\nHow many hosts group are present in the simulation.\r\n\r\n\r\nInterface settings (used to define the possible interfaces the nodes can have)\r\n---\r\n\r\ntype\r\nWhat class (from the interfaces-directory) is used for this interface\r\n\r\nThe remaining settings are class-specific.  Can be for example:\r\n\r\ntransmitRange\r\nRange (meters) of the interface.\r\n\r\ntransmitSpeed\r\nTransmit speed of the interface (bytes per second).\r\n\r\n\r\nHost group settings (used in Group or GroupN namespace):\r\n---\r\n\r\ngroupID \r\nGroup's identifier (a string or a character). Used as the prefix of host \r\nnames that are shown in the GUI and reports. Host's full name is \r\ngroupID+networkAddress.\r\n\r\nnrofHosts \r\nNumber of hosts in this group.\r\n\r\nnrofInterfaces\r\nNumber of interfaces this the nodes of this group use\r\n\r\ninterfaceX\r\nThe interface that should be used as the interface number X\r\n\r\nmovementModel\r\nThe movement model all hosts in the group use. Must be a valid class (one \r\nthat is a subclass of MovementModel class) name from the movement package.\r\n\r\nwaitTime\r\nMinimum and maximum (two comma-separated decimal values) of the wait time \r\ninterval (seconds). Defines how long nodes should stay in the same place \r\nafter reaching the destination of the current path. A new random value within \r\nthe interval is used on every stop. Default value is 0,0.\r\n\r\nspeed\r\nMinimum and maximum (two comma-separated decimal values) of the speed \r\ninterval (m/s). Defines how fast nodes move. A new random value is used on \r\nevery new path. Default value is 1,1.\r\n\r\nbufferSize\r\nSize of the nodes' message buffer (bytes). When the buffer is full, node can't \r\naccept any more messages unless it drops some old messages from the buffer.\r\n\r\nrouter\r\nRouter module which is used to route messages. Must be a valid class \r\n(subclass of MessageRouter class) name from routing package.\r\n\r\nactiveTimes \r\nTime intervals (comma-separated simulated time value tuples: start1, end1, \r\nstart2, end2, ...) when the nodes in the group should be active. If no \r\nintervals are defined, nodes are active all the time.\r\n\r\nmsgTtl\r\nTime To Live (simulated minutes) of the messages created by this host group.  \r\nNodes (with active routing module) check every one minute whether some of \r\ntheir messages' TTLs have expired and drop such messages. If no TTL is \r\ndefined, infinite TTL is used.\r\n\r\n\r\nGroup and movement model specific settings (only meaningful for certain \r\nmovement models):\r\n\r\npois \r\nPoints Of Interest indexes and probabilities (comma-separated \r\nindex-probability tuples: poiIndex1, poiProb1, poiIndex2, poiProb2, ... ). \r\nIndexes are integers and probabilities are decimal values in the range of \r\n0.0-1.0. Setting defines the POI groups where the nodes in this host group \r\ncan choose destinations from and the probabilities for choosing a certain POI \r\ngroup. For example, a (random) POI from the group defined in the POI file1 \r\n(defined with PointsOfInterest.poiFile1 setting) is chosen with the \r\nprobability poiProb1. If the sum of all probabilities is less than 1.0, a \r\nprobability of choosing any random map node for the next destination is (1.0 \r\n- theSumOfProbabilities). Setting can be used only with \r\nShortestPathMapBasedMovement -based movement models. \r\n\r\nokMaps\r\nWhich map node types (refers to map file indexes) are OK for the group \r\n(comma-separated list of integers).  Nodes will not travel trough map nodes \r\nthat are not OK for them. As default, all map nodes are OK. Setting can be \r\nused with any MapBasedMovent -based movement model.\r\n\r\nrouteFile\r\nIf MapRouteMovement movement model is used, this setting defines the route \r\nfile (path) where the route is read from. Route file should contain \r\nLINESTRING WKT directives. Each vertex in a LINESTRING represents one stop \r\non the route.\r\n\r\nrouteType\r\nIf MapRouteMovement movement model is used, this setting defines the routes \r\ntype. Type can be either circular (value 1) or ping-pong (value 2). See \r\nmovement.map.MapRoute class for details.\r\n\r\n\r\nMovement model settings:\r\n---\r\n\r\nMovementModel.rngSeed\r\nThe seed for all movement models' random number generator. If the seed and \r\nall the movement model related settings are kept the same, all nodes should \r\nmove the same way in different simulations (same destinations and speed & \r\nwait time values are used).\r\n\r\nMovementModel.worldSize\r\nSize of the simulation world in meters (two comma separated values: \r\nwidth, height).\r\n\r\nPointsOfInterest.poiFileN\r\nFor ShortestPathMapBasedMovement -based movement models, this setting defines \r\nthe WKT files where the POI coordinates are read from. POI coordinates are \r\ndefined using the POINT WKT directive. The \"N\" in the end of the setting must \r\nbe a positive integer (i.e., poiFile1, poiFile2, ...).\r\n\r\nMapBasedMovement.nrofMapFiles\r\nHow many map file settings to look for in the settings file. \r\n\r\nMapBasedMovement.mapFileN\r\nPath to the Nth map file (\"N\" must be a positive integer). There must be at \r\nleast nrofMapFiles separate files defined in the configuration files(s). All \r\nmap files must be WKT files with LINESTRING and/or MULTILINESTRING WKT \r\ndirectives. Map files can contain POINT directives too, but those are \r\nskipped. This way the same file(s) can be used for both POI and map data. By \r\ndefault the map coordinates are translated so that the upper left corner of \r\nthe map is at coordinate point (0,0). Y-coordinates are mirrored before \r\ntranslation so that the map's north points up in the playfield view. Also all \r\nPOI and route files are translated to match to the map data transformation.\r\n\r\n\r\nReport settings:\r\n---\r\n\r\nReport.nrofReports\r\nHow many report modules to load. Module names are defined with settings \r\n\"Report.report1\", \"Report.report2\", etc. Following report settings can be \r\ndefined for all reports (using Report name space) or just for certain reports \r\n(using ReportN name spaces).\r\n\r\nReport.reportDir\r\nWhere to store the report output files. Can be absolute path or relative to \r\nthe path where the simulation was started. If the directory doesn't exists, \r\nit is created.\r\n\r\nReport.warmup\r\nLength of the warm up period (simulated seconds from the start). During the \r\nwarm up the report modules should discard the new events. The behavior is \r\nreport module specific so check the (java)documentation of different report\r\nmodules for details.\r\n\r\n\r\nEvent generator settings:\r\n---\r\n\r\nEvents.nrof\r\nHow many event generators are loaded for the simulation. Event generator \r\nspecific settings (see below) are defined in EventsN namespaces (so \r\nEvents1.settingName configures a setting for the 1st event generator etc.).\r\n\r\nEventsN.class\r\nName of the generator class to load (e.g., ExternalEventsQueue or \r\nMessageEventGenerator). The class must be found from the input package.\r\n\r\nFor the ExternalEventsQueue you must at least define the path to the external \r\nevents file (using setting \"filePath\"). See input.StandardEventsReader class' \r\njavadocs for information about different external events.\r\n\r\n\r\nOther settings:\r\n---\r\n\r\nOptimization.randomizeUpdateOrder\r\nShould the order in which the nodes' update method is called be randomized.\r\nCall to update causes the nodes to check their connections and also update \r\ntheir routing module. If set to false, node update order is the same as their \r\nnetwork address order. With randomizing, the order is different on every time \r\nstep.\r\n\r\nOptimization.cellSizeMult\r\nAdjust the trade-off between memory consumption and simulation speed. \r\nEspecially useful for large maps. See ConnectivityOptimizer class for details.\r\n\r\n\r\nGUI\r\n===\r\n\r\nThe GUI's main window is divided into three parts. The main part contains\r\nthe playfield view (where node movement is displayed) and simulation and\r\nGUI control and information. The right part is used to select nodes and\r\nthe lower part is for logging and breakpoints.\r\n\r\nThe main part's topmost section is for simulation and GUI controls. The\r\nfirst field shows the current simulation time. Next field shows the\r\nsimulation speed (simulated seconds per second). The following four\r\nbuttons are used to pause, step, fast forward, and fast forward simulation\r\nto given time. Pressing step-button multiple times runs simulation\r\nstep-by-step. Fast forward (FFW) can be used to skip uninteresting parts\r\nof simulation. In FFW, the GUI update speed is set to a large value. Next\r\ndrop-down is used to control GUI update speed. Speed 1 means that GUI is\r\nupdated on every simulated second. Speed 10 means that GUI is updated only\r\non every 10th second etc. Negative values slow down the simulation. The\r\nfollowing drop-down controls the zoom factor. The last button saves the\r\ncurrent view as a png-image.\r\n\r\nMiddle section, i.e., the playfield view, shows the node placement, map\r\npaths, node identifiers, connections among nodes etc. All nodes are\r\ndisplayed as small rectangles and their radio range is shown as a green\r\ncircle around the node. Node's group identifier and network address (a\r\nnumber) are shown next to each node. If a node is carrying messages, each\r\nmessage is represented by a green or blue filled rectangle. If node\r\ncarries more than 10 messages, another column of rectangles is drawn for\r\neach 10 messages but every other rectangle is now red. You can center the\r\nview to any place by clicking with mouse button on the play field. Zoom\r\nfactor can also be changed using mouse wheel on top of the playfield view.\r\n\r\nThe right part of main window is for choosing a node for closer inspection.\r\nSimply clicking a button shows the node info in main parts lower section.\r\nFrom there more information can be displayed by selecting one of the\r\nmessages the node is carrying (if any) from the drop-down menu. Pressing\r\nthe \"routing info\" button opens a new window where information about the\r\nrouting module is displayed. When a node is chosen, the playfield view is\r\nalso centered on that node and the current path the node is traveling is\r\nshown in red.\r\n\r\nLogging (the lowest part) if divided to two sections, control and log. From\r\nthe control part you can select what kind of messages are shown in the\r\nlog. You can also define if simulation should be paused on certain type of\r\nevent (using the check boxes in the \"pause\" column). Log part displays time\r\nstamped events. All nodes and message names in the log messages are\r\nbuttons and you can get more information about them by clicking the\r\nbuttons.\r\n\r\n\r\nDTN2 Reference Implementation Connectivity\r\n==========================================\r\n\r\nDTN2 connectivity allows bundles to be passed between the ONE and any\r\nnumber of DTN2 routers. This is done through DTN2's External Convergence\r\nLayer Interface.\r\n\r\nWhen DTN2 connectivity is enabled ONE will connect to dtnd routers as\r\nan external convergence layer adapter. ONE will also automatically configure\r\ndtnd through a console connection with a link and route for bundles to reach\r\nthe simulator.\r\n\r\nWhen a bundle is received from dtnd, ONE attempts to match the destination EID\r\nagainst the regular expressions configured in the configuration file (see DTN2\r\nConnectivity Configuration File below). For each matching node a copy of a\r\nmessage is created and routed inside ONE. When the bundle reaches its destination\r\ninside ONE it is delivered to the dtnd router instance attached to the node.\r\nCopies of the bundle payload are stored within 'bundles' directory.\r\n\r\nTo enable this functionality the following steps must be taken:\r\n\r\n1) DTN2 must be compiled and configured with ECL support enabled.\r\n2) DTN2Events event generator must be configured to be loaded into ONE\r\n   as an events class.\r\n3) DTN2Reporter must be configured and loaded into one as a report class.\r\n4) DTN2 connectivity configuration file must be configured as DTN2.configFile\r\n\r\nTo start the simulation:\r\n1) Start all the dtnd router instances.\r\n2) Start ONE.\r\n\r\nExample Configuration (2-4 above)\r\n---------------------------------\r\n\r\nEvents.nrof = 1\r\nEvents1.class = DTN2Events\r\nReport.nrofReports = 1\r\nReport.report1 = DTN2Reporter\r\nDTN2.configFile = cla.conf\r\n\r\nDTN2 Connectivity Configuration File\r\n------------------------------------\r\n\r\nThe DTN2 connectivity configuration file defines which nodes inside ONE\r\nshould connect to which DTN2 router instances. It also defines the EID's\r\nthat the nodes match.\r\n\r\nThe configuration file is composed of comment lines starting with # and\r\nconfiguration lines with the following format:\r\n\r\n<nodeID> <EID regexp> <dtnd host> <ECL port> <console port>\r\n\r\nThe fields have the following meaning:\r\n\r\nnodeID:  \tThe ID of a node inside ONE (integer >= 0)\r\nEID regexp:\tIncoming bundles whose destination EID matches this regexp\r\n\t\twill be forwarded to the node inside ONE.\r\n\t\t(see java.util.regex.Pattern)\r\ndtnd host:\tHostname/IP of the dtnd router to connect to this node.\r\nECL port:\tdtnd router's port listening to ECLAs\r\nconsole port:\tdtnd router's console port\r\n\r\nExample:\r\n# <nodeID> <EID regexp> <dtnd host> <ECL port> <console port>\r\n1 dtn://local-1.dtn/(.*) localhost 8801 5051\r\n2 dtn://local-2.dtn/(.*) localhost 8802 5052\r\n\r\nKnown Issues\r\n------------\r\n\r\nFor DTN2 connectivity related issues, you can contact teemuk@netlab.tkk.fi \r\n\r\n-Quitting dtnd router instances connected to ONE will cause ONE to quit.\r\n\r\n\r\nToolkit\r\n=======\r\n\r\nThe simulation package includes a folder called \"toolkit\" that contains \r\nscripts for generating input and processing the output of the simulator. All \r\n(currently included) scripts are written with Perl (http://www.perl.com/) so \r\nyou need to have it installed before running the scripts. Some post processing \r\nscripts use gnuplot (http://www.gnuplot.info/) for creating graphics. Both of \r\nthe programs are freely available for most of the Unix/Linux and Windows \r\nenvironments. For Windows environment, you may need to change the path to the\r\nexecutables for some of the scripts.\r\n\r\ngetStats.pl \r\nThis script can be used to create bar-plots of various statistics gathered by \r\nthe MessageStatsReport -report module. The only mandatory option is \"-stat\" \r\nwhich is used to define the name of the statistics value that should be parsed \r\nfrom the report files (e.g., \"delivery_prob\" for message delivery \r\nprobabilities). Rest of the parameters should be MessageStatsReport output \r\nfilenames (or paths). Script creates three output files: one with values from \r\nall the files, one with the gnuplot commands used to create the graphics and \r\nfinally an image file containing the graphics. One bar is created to the plot \r\nfor each input file. The title for each bar is parsed from the report filename \r\nusing the regular expression defined with \"-label\" option. Run getStats.pl \r\nwith \"-help\" option for more help.\r\n\r\nccdfPlotter.pl\r\nScript for creating Complementary(/Inverse) Cumulative Distribution Function \r\nplots (using gluplot) from reports that contain time-hitcount-tuples. Output \r\nfilename must be defined with the \"-out\" option and rest of the parameters \r\nshould be (suitable) report filenames. \"-label\" option can be used for \r\ndefining label extracting regular expression (similar to one for the getStats \r\nscript) for the legend.\r\n\r\ncreateCreates.pl\r\nMessage creation pattern for the simulation can be defined with external events \r\nfile. Such a file can be simply created with any text editor but this script \r\nmakes it easier to create a large amount of messages. Mandatory options are \r\nthe number of messages (\"-nrof\"), time range (\"-time\"), host address range \r\n(\"-hosts\") and message size range (\"-sizes\"). The number of messages is simply \r\nan integer but the ranges are given with two integers with a colon (:) between \r\nthem. If hosts should reply to the messages that they receive, size range of \r\nthe reply messages can be defined with \"-rsizes\" option. If a certain random \r\nnumber generator seed should be used, that can be defined with \"-seed\" option. \r\nAll random values are drawn from a uniform distribution with inclusive minimum \r\nvalue and exclusive maximum value. Script outputs commands that are suitable \r\nfor external events file's contents. You probably want to redirect the output \r\nto some file.\r\n\r\ndtnsim2parser.pl and transimsParser.pl\r\nThese two (quite experimental) parsers convert data from other programs to a \r\nform that is suitable for ONE. Both take two parameters: input and output \r\nfile. If these parameters are omitted, stdin and stdout are used for input and \r\noutput. With \"-h\" option a short help is printed.\r\ndtnsim2parser converts dtnsim2's (http://watwire.uwaterloo.ca/DTN/sim/) output \r\n(with verbose mode 8) to an external events file that can be fed to ONE. The \r\nmain idea of this parser is that you can first create a connectivity pattern \r\nfile using ONE and ConnectivityDtnsim2Report, feed that to dtnsim2 and then \r\nobserve the results visually in ONE (using the output converted with \r\ndtnsim2parser as the external events file).\r\ntransimsParser can convert TRANSIM's (http://transims-opensource.net/) vehicle \r\nsnapshot files to external movement files that can be used as an input for \r\nnode movement. See ExternalMovement and ExternalMovementReader classes for \r\nmore information.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}